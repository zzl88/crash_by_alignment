# crash_by_alignment
Critical finding:
```
(gdb) bt
#0  0x00007ffff715d9bd in free () from /lib64/libc.so.6
#1  0x0000000000401fb6 in __gnu_cxx::new_allocator<char>::deallocate (this=0x7fffffffdb38, 
    __p=0x200 <error: Cannot access memory at address 0x200>)
    at /usr/include/c++/8/ext/new_allocator.h:125
#2  0x0000000000401ddd in std::allocator_traits<std::allocator<char> >::deallocate (__a=..., 
    __p=0x200 <error: Cannot access memory at address 0x200>, __n=2)
    at /usr/include/c++/8/bits/alloc_traits.h:462
#3  0x0000000000401c5c in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_destroy (this=0x7fffffffdb38, __size=1) at /usr/include/c++/8/bits/basic_string.h:226
#4  0x0000000000401b1a in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::_M_dispose (this=0x7fffffffdb38) at /usr/include/c++/8/bits/basic_string.h:221
#5  0x00000000004019ee in std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >::~basic_string (this=0x7fffffffdb38, __in_chrg=<optimized out>)
    at /usr/include/c++/8/bits/basic_string.h:657
#6  0x000000000040231e in Bar::~Bar (this=0x7fffffffdb10, __in_chrg=<optimized out>) at bar.h:3
#7  0x0000000000402258 in main () at main.cc:6
(gdb) f 6
#6  0x000000000040231e in Bar::~Bar (this=0x7fffffffdb10, __in_chrg=<optimized out>) at bar.h:3
3	struct Bar {
(gdb) p sizeof(Bar)
$1 = 65
(gdb) p sizeof(*this)
$2 = 72
```

Crashing in `Bar::~Bar()` because
* compilation unit `bar.cc` uses packed `std::string`, whose alignment is 1, meaning no padding after `char c;`.
* compilatioin unit `main.cc` includes the original `std::string` header and alignment is 8, thus `m` is aligned as 8 and `char c;` is padded.
* the destructor `Bar::~Bar()` is generated by compiler and inlined in compilation unit `main.cc`, it tries to destruct `m` on the wrong memory location. (Running `foo` with `gdb`, we can find neither `m` nor `n` is constructed on `0x7fffffffdb38`).

Obviously `<string>` shouldn't be packed in `foo.h`. And notice that it's quite easy to hide the actual problem:
* for `bar.h`, put `#include <string>` as the first include header: `Bar` will use the "desired" `std::string`,
* for `class Bar`, move `char c;` after `std::string m;`: destructing `n` and `m` won't crash although inconsistency of `Bar` size still exsits.
* for `class Bar`, define `Bar::~Bar()` explicitly in `bar.cc`: to prevent inlined compiler generated destructor.
